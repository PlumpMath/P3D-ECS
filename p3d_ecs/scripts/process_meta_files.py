"""

Processes all meta files

TODO: Replace all isinstances() with something more generic/polymorphic

"""

from __future__ import print_function

import importlib
import inspect
import subprocess

from os.path import isfile, isdir, join, realpath, dirname
from os import listdir

import sys

BASE_DIR = join(realpath(dirname(__file__)), "..", "..")
sys.path.insert(0, BASE_DIR)

from p3d_ecs.meta.component_properties import BaseProperty


def generate_additional_component_includes(members):
    includes = set()
    for member_name, member_type in members:
        if hasattr(member_type, "includes"):
            for inc in member_type.includes:
                includes.add(inc)

    out = "// AUTOGEN:: aditional includes\n"
    for include in includes:
        out += '#include ' + include + '\n'
    out += "\n"
    if not includes:
        return ""
    return out


def generate_component_member_attributes(members, indent="  "):
    out = indent + "// AUTOGEN:: internal members\n"

    for member_name, member_type in members:
        internal_name = "_" + member_name
        out += indent + member_type.DATA_TYPE + " " + internal_name + ";\n"
        if member_type.NEEDS_DEFAULT_MEMBER:
            out += indent + "static const " + member_type.DATA_TYPE + \
                " " + internal_name + "_DEFAULT;\n"
        if member_type.NEEDS_FILLIN:
            out += indent + member_type.FILLIN_STORAGE_TYPE + \
                " " + internal_name + "_FILLIN_CACHE;\n"

        out += "\n"

    return out


def generate_component_accessors(members, indent="  "):
    out = indent + "// AUTOGEN:: accessors\n"

    def ref_type(member, const=True):
        const_pref = "const " if const else ""
        if member.PASS_AS_REF:
            return "const " + member.DATA_TYPE + "&"
        return member.DATA_TYPE

    for member_name, member_type in members:
        # Getter
        if member_type.generate_getter:
            out += indent + "inline " + \
                ref_type(member_type) + " get_" + member_name + "() const { "
            out += "return _" + member_name + "; }\n"

        # Setter
        if member_type.generate_setter:
            out += indent + "inline void set_" + member_name + \
                "(" + ref_type(member_type) + " val) { "
            out += "_" + member_name + " = val; }\n"

        if member_type.generate_setter or member_type.generate_getter:
            out += "\n"

    return out


def generate_component_constructor_init(members, cls_name, indent="  "):
    out = indent + "// AUTOGEN:: constructor\n"
    out += indent + "inline " + cls_name + \
        "(Entity* entity) : Component(entity)\n"
    for member_name, member_type in members:
        if member_type.init_with is not None:
            init = str(member_type.init_with)
            if member_type.NEEDS_DEFAULT_MEMBER:
                init = "_" + member_name + "_DEFAULT"

            out += indent + "  , _" + member_name + "(" + init + ")\n"
    out += indent + "  { ECS_ON_CREATE(\"" + cls_name + "\"); };\n\n"
    out += indent + "~" + cls_name + \
        "() { ECS_ON_DELETE(\"" + cls_name + "\"); };\n"
    return out


def generate_cpp_header_component_definition(name, members, index):
    cls_name = name + "Meta"

    out = "#pragma once\n\n"
    out += "// AUTOGENERATED. DO NOT EDIT!\n"
    out += "// Instead modify the component meta file.\n\n"
    out += "#ifndef P3D_ECS_" + name.upper() + "_METACLS_H\n"
    out += "#define P3D_ECS_" + name.upper() + "_METACLS_H\n\n"
    out += '#include "config_module.h"\n'
    out += '#include "component.h"\n'
    out += '#include "leak_detector.h"\n'
    out += '#include "memory_pool.h"\n'
    out += '#include "luse.h"\n'
    out += '#include "uuid.h"\n'
    out += '#include <string>\n'
    out += "\n"
    out += generate_additional_component_includes(members)
    out += "class Entity;\n"
    out += "class EntityManager;\n"
    out += "class " + name + ";\n\n"
    out += "class " + cls_name + " : public Component {\n"

    out += "protected:\n"
    out += "  using superclass = " + cls_name + ";\n\n"
    out += "public:\n"
    out += "  DEFINE_COMPONENT_BASE();\n\n"

    out += generate_component_accessors(members, "  ")
    out += "  // AUTOGEN:: serialization\n"
    out += "\n"
    out += "#ifndef INTERROGATE\n"
    out += "  virtual void serialize(p3d_ecs::proto::Components* dest) const override;\n"
    out += "  void deserialize(const p3d_ecs::proto::" + name + "& message);\n"
    out += "  virtual bool data_equals(const Component& other) const override;\n"
    out += "  virtual void fillin_ptrs() override;\n"
    out += "#endif\n"
    out += "\n"
    out += "protected:\n"
    out += generate_component_constructor_init(members, cls_name, "  ")
    out += generate_component_member_attributes(members, "  ")

    out += "};\n"

    out += "#endif\n"
    return out


def generate_cpp_file_component_definition(py_name, name, members, index, cid):
    cls_name = name + "Meta"
    out = "\n"
    out += "// AUTOGENERATED. DO NOT EDIT!\n"
    out += "// Instead modify the component meta file.\n\n"
    out += '#include "' + py_name + '_meta.h"\n'
    out += '#include "entity.h"\n'
    out += '#include "serialization_helpers.h"\n'
    out += '#include "entity_manager.h"\n\n'
    out += '#include <functional>\n'

    out += "IMPLEMENT_COMPONENT_BASE(" + name + \
        ", " + cls_name + ", " + str(cid) + "u);\n"
    out += "\n"

    for member_name, member_type in members:
        if member_type.NEEDS_DEFAULT_MEMBER:
            out += "const " + member_type.DATA_TYPE + " " + \
                cls_name + "::_" + member_name + "_DEFAULT = "
            out += member_type.generate_default_object() + ";\n"
    out += "\n"

    # serialization
    out += "void\n" + cls_name + \
        "::serialize(p3d_ecs::proto::Components* dest) const {\n"
    indent = "  "
    out += indent + "auto* proto_obj = dest->mutable_" + py_name + "();\n\n"
    for member_name, member_type in members:
        if member_type.serialization_id is None:
            # Skip non-serialized members
            continue
        if member_type.CUSTOM_SERIALIZATION:
            out += member_type.serialize_to_proto_custom(
                "proto_obj", member_name, indent)
        else:
            out += indent + \
                "if (" + member_type.check_for_default("_" +
                                                       member_name) + ") {\n"
            out += indent + "  " + \
                member_type.serialize_to_proto(
                    "proto_obj", member_name) + ";\n"
            out += indent + "}\n"
        pass
    out += "}\n\n"

    # deserialization
    out += "void\n" + cls_name + \
        "::deserialize(const p3d_ecs::proto::" + name + "& message) {\n"
    indent = "  "
    # Default non-serialized members, TODO: maybe we should let the user do
    # this to improve performance (?!)

    def setdefault(member_name, member_type):
        out = indent + "_" + member_name + " = "
        if member_type.NEEDS_DEFAULT_MEMBER:
            return out + "_" + member_name + "_DEFAULT;\n"
        return out + member_type.generate_default_object() + ";\n"

    for member_name, member_type in members:
        if member_type.serialization_id is None:
            out += setdefault(member_name, member_type)
            continue

    out += "\n"

    # Read in other members
    for member_name, member_type in members:
        if member_type.serialization_id is not None:
            if member_type.CUSTOM_DESERIALIZATION:
                out += member_type.deserialize_from_proto_custom(
                    "message", member_name, indent)
            else:
                out += "\n" + indent + "// Member: " + member_name + "\n"
                out += indent + "if (!message.has_" + member_name + "()) {\n"
                out += "  " + setdefault(member_name, member_type)
                out += indent + "} else {\n"
                out += indent + "  " + \
                    member_type.deserialize_from_proto(
                        "message", member_name) + ";\n"
                out += indent + "}\n"
    out += "\n"
    out += "}\n\n"

    # fillin_ptrs
    needs_fillin = False

    # Don't fillin when no properties actually need to filin
    for member_name, member_type in members:
        if member_type.serialization_id is not None and member_type.NEEDS_FILLIN:
            needs_fillin = True

    out += "void\n" + cls_name + "::fillin_ptrs() {\n"
    if not needs_fillin:
        out += "  // No properties which require fillin detected.\n"
    else:
        out += "  EntityManager* mgr = _entity->get_manager();\n"
        for member_name, member_type in members:
            if member_type.serialization_id is not None and member_type.NEEDS_FILLIN:
                out += member_type.fillin_ptrs(member_name, indent="  ")

    out += "}\n\n"

    # data_equals
    out += "bool\n" + cls_name + \
        "::data_equals(const Component &other) const {\n"
    out += "  // Notice: Its not required to check if we are comparing against ourself.\n"
    out += "  // This is because data_equals can only be called from an entity, and\n"
    out += "  // the entity already checks for pointer equalness.\n"
    out += "  const " + cls_name + \
        "& other_ref = static_cast<const " + cls_name + "&>(other);\n\n"

    for member_name, member_type in members:
        out += "  if (!(" + member_type.compare_to("_" + member_name,
                                                   "other_ref._" + member_name, convert_type=False) + "))\n"
        out += "    return false;\n"

    out += "  return true;"
    out += "\n}\n\n"

    return out


def parse_template(source, defines):
    with open(source) as handle:
        content = handle.read()
    for key, val in defines.items():
        content = content.replace("${" + key + "}", str(val))
    return content


def generate_component_proto_file(component_id, class_name, members):
    out = "syntax = \"proto3\";\n"
    out += "package p3d_ecs.proto;\n"
    out += "\n"

    imports = set()
    for member_name, member_type in members:
        if member_type.serialization_id is not None and member_type.PROTO_INC is not None:
            imports.add(member_type.PROTO_INC)
    for import_file in imports:
        out += "import \"" + import_file + "\";\n"

    out += "\n"
    out += "message " + class_name + " {\n\n"
    for member_name, member_type in members:
        if member_type.serialization_id is None:
            continue
        out += "  " + member_type.PROTO_TYPE + " " + member_name + \
            " = " + str(member_type.serialization_id) + ";\n"

    out += "\n}\n"

    dest = join(BASE_DIR, "p3d_ecs", "proto",
                "components_gen", component_id + "_meta.proto")
    with open(dest, "w") as handle:
        handle.write(out)


def process_meta_component(py_file, filename, index):
    py_name = filename.replace(".py", "")
    camelcase_name = py_name.title().replace("_", "")
    print("Processing component", camelcase_name)

    module = importlib.import_module(
        ("p3d_ecs.component_meta.{}".format(py_name)))
    if not hasattr(module, camelcase_name):
        print("ERROR: Component class not found in", py_file)
        return False

    component_class = getattr(module, camelcase_name)
    pred = lambda m: isinstance(m, BaseProperty)
    members = inspect.getmembers(component_class, pred)
    members = sorted(members, key=lambda kv_pair: kv_pair[1].serialization_id or 0)

    generate_component_proto_file(py_name, camelcase_name, members)

    cpp_name = py_name + "_meta.cpp"
    header_name = py_name + "_meta.h"

    header_code = generate_cpp_header_component_definition(
        camelcase_name, members, index)
    cpp_code = generate_cpp_file_component_definition(
        py_name, camelcase_name, members, index, component_class.ID)

    source_dir = join(BASE_DIR, "p3d_ecs", "native", "source")
    destination = join(source_dir, "component_meta")

    with open(join(destination, header_name), "w") as handle:
        handle.write(header_code)

    with open(join(destination, cpp_name), "w") as handle:
        handle.write(cpp_code)

    impl_dir = join(source_dir, "component_impl")
    impl_header = join(impl_dir, py_name + ".h")
    impl_cpp = join(impl_dir, py_name + ".cpp")

    if not isfile(impl_cpp):
        print(" -> Adding cpp template for", py_file)
        with open(impl_cpp, "w") as handle:
            handle.write('\n#include "' + py_name + '.h"\n\n')

    if not isfile(impl_header):
        print(" -> Adding header template for", py_file)
        template_params = {
            "CLASSNAME_UPPER": py_name.upper(),
            "META_HEADER": py_name + "_meta.h",
            "CLASSNAME": camelcase_name,
        }
        prefab = join(BASE_DIR, "p3d_ecs", "script_templates",
                      "new_component.templ.h")
        content = parse_template(prefab, template_params)
        with open(impl_header, "w") as handle:
            handle.write(content)

    return py_name, camelcase_name, component_class.ID


def process_component_metafiles():
    meta_path = join(BASE_DIR, "p3d_ecs", "component_meta")
    component_index = 1
    components = []
    processed_cids = set()

    # Notice: we use sorted to ensure we always have the same order
    for f in sorted(listdir(meta_path)):
        abspath = join(meta_path, f)
        if isfile(abspath) and f.endswith("_component.py"):
            components.append(process_meta_component(
                abspath, f, component_index))
            component_index += 1
            cid = components[-1][2]
            if cid in processed_cids:
                print("ERROR: Double component ID! on", components[-1])
            processed_cids.add(cid)

    components = sorted(components, key=lambda _: _[2])

    # Write the combined all_components header
    source_dir = join(BASE_DIR, "p3d_ecs", "native", "source")
    all_components_file = join(source_dir, "all_components_gen.h")
    with open(all_components_file, "w") as handle:
        handle.write("#pragma once\n")
        handle.write("#ifndef P3D_ECS_ALL_COMPONENTS_H\n")
        handle.write("#define P3D_ECS_ALL_COMPONENTS_H\n")
        handle.write("// AUTOGENERATED. DO NOT EDIT!\n\n")
        handle.write("#ifndef INTERROGATE\n")
        handle.write('#include "components.pb.h"\n')
        # for (py_name, cls_name, cid) in components:
        #     handle.write('#include "' + py_name + '.h"\n')
        # handle.write('#include "' + py_name + '_meta.pb.h"\n')
        handle.write("\nclass Entity;\n\n")
        handle.write(
            "void deserialize_components(Entity* entity, const p3d_ecs::proto::Components& components);\n\n")
        handle.write("#endif\n")
        handle.write("#endif\n")

    all_components_cpp = join(source_dir, "all_components_gen.cpp")
    with open(all_components_cpp, "w") as handle:
        handle.write("// AUTOGENERATED. DO NOT EDIT!\n\n")
        handle.write('#include "all_components_gen.h"\n')
        handle.write('#include "entity.h"\n\n')
        for (py_name, cls_name, cid) in components:
            handle.write('#include "' + py_name + '.h"\n')
            handle.write('#include "' + py_name + '_meta.pb.h"\n')
        handle.write("\n")
        handle.write(
            "void\ndeserialize_components(Entity* entity, const p3d_ecs::proto::Components& components) {\n")
        for (py_name, cls_name, cid) in components:
            handle.write("\n  if (components.has_" + py_name + "()) {\n")
            handle.write(
                "    " + cls_name + "& component = entity->new_component<" + cls_name + ">();\n")
            handle.write(
                "    component.deserialize(components." + py_name + "());\n")
            handle.write("  }\n")
        handle.write("}\n")

    # Write the combined proto component type
    all_proto_file = join(BASE_DIR, "p3d_ecs", "proto", "components.proto")
    with open(all_proto_file, "w") as handle:
        handle.write("syntax = \"proto3\";\n")
        handle.write("package p3d_ecs.proto;\n\n")
        handle.write("// Autogenerated, do not edit!\n\n")

        for (py_name, cls_name, cid) in components:
            handle.write("import \"components_gen/" +
                         py_name + "_meta.proto\";\n")

        handle.write("\nmessage Components {\n\n")
        for (py_name, cls_name, cid) in components:
            handle.write("  p3d_ecs.proto." + cls_name + " " +
                         py_name + " = " + str(cid) + ";\n")

        handle.write("}\n")

    print("Running proto compiler ..")
    subprocess.check_output([sys.executable, join(
        BASE_DIR, "p3d_ecs", "scripts", "compile_proto_files.py")])
    print("Done!")


if __name__ == "__main__":
    process_component_metafiles()
