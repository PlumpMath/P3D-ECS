
// AUTOGENERATED. DO NOT EDIT!
// Instead modify the component meta file.

#include "transform_component_meta.h"
#include "entity.h"
#include "serialization_helpers.h"
#include "entity_manager.h"

#include <functional>
IMPLEMENT_COMPONENT_BASE(TransformComponent, TransformComponentMeta, 1u);

const LMatrix4f TransformComponentMeta::_absolute_matrix_DEFAULT = LMatrix4f(LMatrix4f::ident_mat());
const LVecBase3f TransformComponentMeta::_hpr_DEFAULT = LVecBase3f(0);
const LVecBase3f TransformComponentMeta::_pos_DEFAULT = LVecBase3f(0);
const LVecBase3f TransformComponentMeta::_scale_DEFAULT = LVecBase3f(1, 1, 1);
const LMatrix4f TransformComponentMeta::_matrix_DEFAULT = LMatrix4f(LMatrix4f::ident_mat());

void
TransformComponentMeta::serialize(p3d_ecs::proto::Components* dest) const {
  auto* proto_obj = dest->mutable_transform_component();

  if (!_matrix.almost_equal(_matrix_DEFAULT)) {
    serialize_LMatrix4f(_matrix, proto_obj->mutable_matrix());
  }
  if (!(_parent == nullptr)) {
    proto_obj->set_parent(_parent->get_uuid().c_str(), UUID::uuid_length);
  }
  for (auto& elem : _children) {
     proto_obj->add_children(elem->get_uuid().c_str(), UUID::uuid_length);
  }
}

void
TransformComponentMeta::deserialize(const p3d_ecs::proto::TransformComponent& message) {
  _abs_matrix_is_dirty = false;
  _absolute_matrix = _absolute_matrix_DEFAULT;
  _hpr = _hpr_DEFAULT;
  _pos = _pos_DEFAULT;
  _scale = _scale_DEFAULT;

  if (!message.has_matrix()) {
    _matrix = _matrix_DEFAULT;
  } else {
    deserialize_LMatrix4f(_matrix, message.matrix());
  }
  deserialize_Entity(_parent, _parent_FILLIN_CACHE, message.parent());
  deserialize_VectorOfEntity(_children, _children_FILLIN_CACHE, message.children());

}

void
TransformComponentMeta::fillin_ptrs() {
  EntityManager* mgr = _entity->get_manager();
  fillin_Entity(mgr, _parent_FILLIN_CACHE, _parent);
  fillin_VectorOfEntity(mgr, _children_FILLIN_CACHE, _children);
}

bool
TransformComponentMeta::data_equals(const Component &other) const {
  // Notice: Its not required to check if we are comparing against ourself.
  // This is because data_equals can only be called from an entity, and
  // the entity already checks for pointer equalness.
  const TransformComponentMeta& other_ref = static_cast<const TransformComponentMeta&>(other);

  if (!(_abs_matrix_is_dirty == other_ref._abs_matrix_is_dirty))
    return false;
  if (!(_absolute_matrix.almost_equal(other_ref._absolute_matrix)))
    return false;
  if (!(_hpr.almost_equal(other_ref._hpr)))
    return false;
  if (!(_pos.almost_equal(other_ref._pos)))
    return false;
  if (!(_scale.almost_equal(other_ref._scale)))
    return false;
  if (!(_matrix.almost_equal(other_ref._matrix)))
    return false;
  if (!(_parent == other_ref._parent))
    return false;
  if (!(::p3d_ecs::performance::compare_flat_sets(_children, other_ref._children)))
    return false;
  return true;
}

